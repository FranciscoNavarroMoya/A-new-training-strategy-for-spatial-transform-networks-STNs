# # -*- coding: utf-8 -*-
# """Simulador_dos_camaras.ipynb
#
# Automatically generated by Colaboratory.
#
# Original file is located at
#     https://colab.research.google.com/drive/1lIcbj0bs5AnW2mtojdGkASv0lZkdN_EW
# """

import numpy as np
import cv2
import os
from PIL import Image
from torchvision.transforms import transforms
from math import pi
import math
import random

def simulator(S):
    random.seed(S)
    incX = random.random()
    incY = random.random()
    X = np.array(
        [[(0.75 + 0.5 * incX) * -40, (0.75 + 0.5 * incX) * -40, (0.75 + 0.5 * incX) * 40, (0.75 + 0.5 * incX) * 40],
         [(0.75 + 0.5 * incY) * -150, (0.75 + 0.5 * incY) * 150, (0.75 + 0.5 * incY) * 150, (0.75 + 0.5 * incY) * -150],
         [0, 0, 0, 0], [1, 1, 1, 1]], dtype=np.int32)

    ang = 2*pi*random.random()
    D = math.sqrt(X[0][0] * X[0][0] + X[1][0] * X[1][0])
    X1 = np.array([[D * math.cos(ang + math.atan2(X[1][0], X[0][0])), D * math.cos(ang + math.atan2(X[1][1], X[0][1])),
                    D * math.cos(ang + math.atan2(X[1][2], X[0][2])), D * math.cos(ang + math.atan2(X[1][3], X[0][3]))],
                   [D * math.sin(ang + math.atan2(X[1][0], X[0][0])), D * math.sin(ang + math.atan2(X[1][1], X[0][1])),
                    D * math.sin(ang + math.atan2(X[1][2], X[0][2])), D * math.sin(ang + math.atan2(X[1][3], X[0][3]))],
                   [0, 0, 0, 0], [1, 1, 1, 1]], dtype=np.int32)
    trasX = int(-100+150*random.random())
    trasY = int(-100+150*random.random())
    X = np.array([[X1[0][0] + trasX, X1[0][1] + trasX, X1[0][2] + trasX, X1[0][3] + trasX],
                  [X1[1][0] + trasY, X1[1][1] + trasY, X1[1][2] + trasY, X1[1][3] + trasY], [0, 0, 0, 0],
                  [1, 1, 1, 1]], dtype=np.int32)

    """## **CONFIGURACION DE LA CAMARA**
    Parametros intrinsecos
    """

    fu = 1580   # fu = f/dx
    fv = 1580   # fv = f/dy
    uo = 150    # uo = xo
    vo = 100    # vo = yo

    """Parametros extrinsecos"""
    radio = 1000
    angulo = 180-5

    rX = (pi/180)*(angulo)   # angulo de rotación en el eje X
    rY = 0 		               # angulo de rotación en el eje Y
    rZ = 0 		               # angulo de rotación en el eje Z
    tX = 0             		                     # Traslacion en el eje X
    tY = math.sin((pi/180)*(angulo))*radio     # Traslacion en el eje Y
    tZ = -math.cos((pi/180)*(angulo))*radio    # Traslacion en el eje Z

    """Construccion de la matriz de proyeccion"""

    K = np.array([[fu, 0, uo],[0, fv, vo],[0, 0, 1]])
    K1 = np.array([[fu, 0, uo, 0],[0, fv, vo, 0],[0, 0, 1, 0]])
    Rx = np.array([[1, 0, 0],[0, math.cos(rX), -math.sin(rX)],[0, math.sin(rX), math.cos(rX)]])   # matriz de traslación según rotación en el eje X
    Ry = np.array([[math.cos(rY), 0, math.sin(rY)],[0, 1, 0],[-math.sin(rY), 0, math.cos(rY)]])   # matriz de traslación según rotación en el eje Y
    Rz = np.array([[math.cos(rZ), -math.sin(rZ), 0],[math.sin(rZ), math.cos(rZ), 0],[0, 0, 1]])   # matriz de traslación según rotación en el eje Z
    R = np.dot(np.dot(Rx,Ry),Rz)	      # Matriz de rotación que da la orientación de la camara en el espacio 3D
    T = np.array([[tX], [tY], [tZ]])    # Matriz de traslacion que situa la camara en el espacio 3D

    """Matriz de proyeccion"""

    P = np.dot(K1,np.linalg.inv(np.concatenate((np.concatenate((R, T),axis=1),np.array([[0, 0, 0, 1]])))))

    """Conjunto de puntos en la imagen 2D"""

    U=np.dot(P,X)

    U = np.concatenate([[U[0]/U[2]],[U[1]/U[2]],[np.ones(U[0].shape)]])

    """# Segunda cámara
    
    """
    X = np.array(
        [[(0.75 + 0.5 * incX) * -20, (0.75 + 0.5 * incX) * -20, (0.75 + 0.5 * incX) * 20, (0.75 + 0.5 * incX) * 20],
         [(0.75 + 0.5 * incY) * -60, (0.75 + 0.5 * incY) * 60, (0.75 + 0.5 * incY) * 60, (0.75 + 0.5 * incY) * -60],
         [0, 0, 0, 0], [1, 1, 1, 1]], dtype=np.int32)

    D = math.sqrt(X[0][0] * X[0][0] + X[1][0] * X[1][0])
    X1 = np.array([[D * math.cos(ang + math.atan2(X[1][0], X[0][0])), D * math.cos(ang + math.atan2(X[1][1], X[0][1])),
                    D * math.cos(ang + math.atan2(X[1][2], X[0][2])), D * math.cos(ang + math.atan2(X[1][3], X[0][3]))],
                   [D * math.sin(ang + math.atan2(X[1][0], X[0][0])), D * math.sin(ang + math.atan2(X[1][1], X[0][1])),
                    D * math.sin(ang + math.atan2(X[1][2], X[0][2])), D * math.sin(ang + math.atan2(X[1][3], X[0][3]))],
                   [0, 0, 0, 0], [1, 1, 1, 1]], dtype=np.int32)

    X = np.array([[X1[0][0] + trasX, X1[0][1] + trasX, X1[0][2] + trasX, X1[0][3] + trasX],
                  [X1[1][0] + trasY, X1[1][1] + trasY, X1[1][2] + trasY, X1[1][3] + trasY], [0, 0, 0, 0],
                  [1, 1, 1, 1]], dtype=np.int32)

    fu = 1580 # fu = f/dx
    fv = 1580 # fv = f/dy
    uo = 150 # uo = xo
    vo = 100 # vo = yo


    """Parametros extrinsecos"""

    radio = 1000
    angulo = 180-10

    rX = (pi/180)*(angulo) # angulo de rotación en el eje X
    rY = 0 		# angulo de rotación en el eje Y
    rZ = 0		# angulo de rotación en el eje Z
    tX = -150             		# Traslacion en el eje X
    tY = math.sin((pi/180)*(angulo))*radio-150     # Traslacion en el eje Y
    tZ = -math.cos((pi/180)*(angulo))*radio    # Traslacion en el eje Z

    K = np.array([[fu, 0, uo],[0, fv, vo],[0, 0, 1]])
    K1 = np.array([[fu, 0, uo, 0],[0, fv, vo, 0],[0, 0, 1, 0]])
    Rx = np.array([[1, 0, 0],[0, math.cos(rX), -math.sin(rX)],[0, math.sin(rX), math.cos(rX)]]) #matriz de traslación según rotación en el eje X
    Ry = np.array([[math.cos(rY), 0, math.sin(rY)],[0, 1, 0],[-math.sin(rY), 0, math.cos(rY)]]) #matriz de traslación según rotación en el eje Y
    Rz = np.array([[math.cos(rZ), -math.sin(rZ), 0],[math.sin(rZ), math.cos(rZ), 0],[0, 0, 1]]) #matriz de traslación según rotación en el eje Z
    R = np.dot(np.dot(Rx,Ry),Rz)	# Matriz de rotación que da la orientación de la camara en el espacio 3D
    T = np.array([[tX], [tY], [tZ]]) # Matriz de traslacion que situa la camara en el espacio 3D

    P2 = np.dot(K1,np.linalg.inv(np.concatenate((np.concatenate((R, T),axis=1),np.array([[0, 0, 0, 1]])))))

    U2 = np.dot(P2,X)
    U2 = np.concatenate([[U2[0]/U2[2]],[U2[1]/U2[2]],[np.ones(U2[0].shape)]])


    esquinas = []
    for i in range(4):
      esquinas.append([int(U[0][i])+1296, int(U[1][i])+976])
    esquinas = np.asarray(esquinas)
    esquinas= esquinas.reshape(1,4,2)
    Fondo = 255*np.ones((1944, 2592), np.uint8)
    micro1 = cv2.fillPoly(Fondo,esquinas,0)

    esquinas = []
    for i in range(4):
      esquinas.append([int(U2[0][i])+1296, int(U2[1][i])+976])
    esquinas = np.asarray(esquinas)
    esquinas= esquinas.reshape(1,4,2)
    Fondo = 255*np.ones((1944, 2592), np.uint8)
    micro2 = cv2.fillPoly(Fondo,esquinas,0)

    return micro2, micro1
